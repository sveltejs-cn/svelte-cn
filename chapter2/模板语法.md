# 模板语法

## 标签(Tags)

小写标记（如`<div>`）表示常规HTML元素。大写的标记（如`<widget>`或`<namespace.widget>`）表示组件。

```
<script>
	import Widget from './Widget.svelte';
</script>

<div>
	<Widget/>
</div>
```

## 属性(Attributes)

默认情况下，模板的属性，和其对应的html属性几乎一模一样。

```html
<div class="foo">
	<button disabled>can't touch this</button>
</div>
```

和 `html` 中一样，属性值也可以不被`引号`包裹。

```html
<input type=checkbox>
```

属性值可以包含`javascript`的表达式：

```html
<a href="page/{p}">page {p}</a>
```

或者，属性值本身就是`javascript`的表达式：

```html
<button disabled={!clickable}>...</button>
```

需要注意的是，`javascript`的表达式中，可能会包含一些字符，这些字符会让普通的`html` 代码无法被语法高亮，所以，我们可以使用 `引号`。 

`引号` 不会影响 属性值的解析。

```html
<button disabled="{number !== 42}">...</button>
```

当属性名和值匹配（`name= {name}`）时，可以将它们替换为`{name}`。

```html
<!-- These are equivalent -->
<button disabled={disabled}>...</button>
<button {disabled}>...</button>
```

扩展属性（*Spread attributes* ）允许同时将许多属性或属性传递给元素或组件。

一个元素，或者组件，可以有多个扩展属性。并且拓展属性和正常的html 属性可以共存。

```html
<Widget {...things}/>
```



## 文本表达式(Text expressions)

语法：

```html
{expression}
```

文本还可以包含javascript表达式：

```html
<h1>Hello {name}!</h1>
<p>{a} + {b} = {a + b}.</p>
```



## HTML表达式(HTML expressions)

```html
{@html expression}
```

在文本表达式中，像`<`和`>`这样的字符被转义。而在`HTML表达式` 中，讲不会被转义。

> svelte不会在注入HTML之前，过滤表达式。如果数据是来自不可信的地方，你必须过滤它。否则，你的用户将会面临XSS攻击的危险。

```html
<div class="blog-post">
	<h1>{post.title}</h1>
	{@html post.content}
</div>
```



## 条件渲染 (If blocks)

```html
{#if expression}...{/if}

{#if expression}...{:else if expression}...{/if}

{#if expression}...{:else}...{/if}
```

条件渲染的内容，可以被包裹在 一个 `if ` 块中。

```html
{#if answer === 42}
	<p>what was the question?</p>
{/if}
```

附加条件可以用`{:else if expression}`，也可以选择以`{:else}`结尾。

```html
{#if porridge.temperature > 100}
	<p>too hot!</p>
{:else if 80 > porridge.temperature}
	<p>too cold!</p>
{:else}
	<p>just right!</p>
{/if}
```



##  列表渲染（Each blocks）

```html
{#each expression as name}...{/each}

{#each expression as name, index}...{/each}

{#each expression as name, index (key)}...{/each}

{#each expression as name}...{:else}...{/each}
```

遍历一个数组，可以通过`列表渲染` 来实现。

```html
<h1>Shopping list</h1>
<ul>
	{#each items as item}
		<li>{item.name} x {item.qty}</li>
	{/each}
</ul>
```

每一个 `each  block` ，都可以指定一个 `index` 。 该index的作用和 `array.map()` 的回调方法的第二个参数相同。

```html
{#each items as item, i}
	<li>{i + 1}: {item.name} x {item.qty}</li>
{/each}
```

 如果你指定了 `key`，Svelte 会在数据发生变更的时候，对列表进行diff。

要注意，列表中的每一项的`key` 都必须是唯一的，`key` 可以是任何对象，但建议使用字符串和数字，因为它们允许在对象本身更改时保持标识。

```html
{#each items as item, i (item.id)}
	<li>{i + 1}: {item.name} x {item.qty}</li>
{/each}
```

您可以在每个块中使用es6的语法 : 解构:

```html
{#each items as { id, name, qty }, i (id)}
	<li>{i + 1}: {name} x {qty}</li>
{/each}
```

每个块还可以有一个 `{:else}` 子句，如果列表为空，则呈现该子句。

```html
{#each todos as todo}
	<p>{todo.text}</p>
{:else}
	<p>No tasks today!</p>
{/each}
```



## Await blocks

```html
{#await expression}...{:then name}...{:catch name}...{/await}

{#await expression}...{:then name}...{/await}

{#await expression then name}...{/await}
```

`await block` 可以让你处理，`Promise`的三种状态 `pending`, `fulfilled`, `rejected`

```html
{#await promise}
	<!-- promise is pending -->
	<p>waiting for the promise to resolve...</p>
{:then value}
	<!-- promise was fulfilled -->
	<p>The value is {value}</p>
{:catch error}
	<!-- promise was rejected -->
	<p>Something went wrong: {error.message}</p>
{/await}
```

如果`Promise` `reject`时，或者发生错误时，你不需要渲染任何东西，则`catch` 块可以被忽略。

```html
{#await promise}
	<!-- promise is pending -->
	<p>waiting for the promise to resolve...</p>
{:then value}
	<!-- promise was fulfilled -->
	<p>The value is {value}</p>
{/await}
```

如果你不关心 `pending` 状态，你也可以忽略 `initial` 块。

```html
{#await promise then value}
	<p>The value is {value}</p>
{/await}
```

 

## DOM 事件 (DOM events)

```html
on:eventname={handler}

on:eventname|modifiers={handler}
```

你可以使用 `on:`的写法可以监听DOM 事件：

```html
<script>
	let count = 0;

	function handleClick(event) {
		count += 1;
	}
</script>

<button on:click={handleClick}>
	count: {count}
</button>
```

事件回调函数不会影响性能，会以内联的方式的声明。与属性一样，为了语法高亮，`指令`的值可以被`引号` 包裹。

```html
<button on:click="{() => count += 1}">
	count: {count}
</button>
```

使用 `|` 字符来向DOM事件添加修饰符。

下面的修饰符都是可用的：

- preventDefault： 在 handeler 被调用前，调用 `event.preventDefault()`
- stopPropagation: 阻止事件冒泡
- passive： 提高触摸/滚动事件的滚动性能
- capture：在捕获阶段而不是冒泡阶段，触发事件处理函数
- once: 事件处理函数只会被执一次。

修饰符可以使用 `|` 链接起来：`on:click|once|capture={...}`

```html
<form on:submit|preventDefault={handleSubmit}>
	<!-- the `submit` event's default is prevented,
		 so the page won't reload -->
</form>
```

如果 `on:` 指令，后面没有指定事件回调函数。意味着，这个组件的消费者，将会监听这个事件。

```html
<button on:click>
	The component itself will emit the click event
</button>
```

对于同样的事件，绑定多个事件处理函数，也可以。

```html
<script>
	let counter = 0;
	function increment() {
		counter = counter + 1;
	}

	function track(event) {
		trackEvent(event)
	}
</script>

<button on:click={increment} on:click={track}>Click me!</button>
```

## 组件事件

```html
on:eventname={handler}
```

组件可以通过`createEventDispatcher` 方法触发一个事件。

监听组件的事件，和监听 html 事件一模一样。

```html
<SomeComponent on:whatever={handler}/>
```

和 DOM 事件一样，如果 `on:` 指令，后面没有指定事件回调函数。意味着，这个组件的消费者，将会监听这个事件。

```html
<SomeComponent on:whatever/>
```



## 元素绑定（Element bindings）

```html
bind:property={variable}

bind:group={variable}

bind:this={dom_node}
```

数据通常从父级流向子级。`bind:`指令允许数据以另一种方式从子级流到父级。

大多数的绑定，都需要指定特定元素。

最简单的绑定一个属性的值，比如说，`input.value`

```html
<input bind:value={name}>
<textarea bind:value={text}></textarea>

<input type="checkbox" bind:checked={yes}>
```

如果，属性值和属性名相同，也可以使用如下的写法：

```html
<!-- These are equivalent -->
<input bind:value={value}>
<input bind:value>
```

数值输入值是强制的；即使`input.value`是一个字符串，svelte将把它当作一个数字。如果输入为空或无效（在`type=“number”`的情况下），则该值为 `undefined`。

```html
<input type="number" bind:value={num}>
<input type="range" bind:value={num}>
```



### 绑定相关元素

可以使用 `bind:group` 来让 `input` 一起工作

```html
<script>
	let tortilla = 'Plain';
	let fillings = [];
</script>

<!-- grouped radio inputs are mutually exclusive -->
<input type="radio" bind:group={tortilla} value="Plain">
<input type="radio" bind:group={tortilla} value="Whole wheat">
<input type="radio" bind:group={tortilla} value="Spinach">

<!-- grouped checkbox inputs populate an array -->
<input type="checkbox" bind:group={fillings} value="Rice">
<input type="checkbox" bind:group={fillings} value="Beans">
<input type="checkbox" bind:group={fillings} value="Cheese">
<input type="checkbox" bind:group={fillings} value="Guac (extra)">
```

### 绑定 `<select>` 值

`<select>` 标签上的值，和被选择的`<option>` 标签的 `value` 属性有绑定关系， `value` 属性可以是任何值，而不仅仅是字符串

```html
<select bind:value={selected}>
	<option value={a}>a</option>
	<option value={b}>b</option>
	<option value={c}>c</option>
</select>
```

`<select multiple>` 标签，和 `checkbox` 组类似：

```html
<select multiple bind:value={fillings}>
	<option value="Rice">Rice</option>
	<option value="Beans">Beans</option>
	<option value="Cheese">Cheese</option>
	<option value="Guac (extra)">Guac (extra)</option>
</select>
```

当 `<option>` 标签`value`属性的值，和`<option>` 中的文本内容相同，则 `value ` 属性可以呗省略。

### 绑定媒体元素

类似于 `audio` 和 `video` 等媒体元素，他们有自己的一套绑定规则。

四个只读的属性

- duration : video 播放的总长度，单位是秒
- buffered
- seekable
- played

还有三个可以双向绑定的属性

- currentTime： 当前视频的播放点
- paused： 是否是暂停
- volume： 音量，在 0和 1 之间

```html
<video
	src={clip}
	bind:duration
	bind:buffered
	bind:seekable
	bind:played
	bind:currentTime
	bind:paused
	bind:volume
></video>
```



### 绑定块级元素

块级 元素有4个只读的绑定：

- clientWidth
- `clientHeight`
- `offsetWidth`
- `offsetHeight`



```html
<div
	bind:offsetWidth={width}
	bind:offsetHeight={height}
>
	<Chart {width} {height}/>
</div>

```



### 绑定DOM节点

使用 `bind:this` ，可以创建一个到DOM节点的引用

```php+HTML
<script>
	import { onMount } from 'svelte';

	let canvasElement;

	onMount(() => {
		const ctx = canvasElement.getContext('2d');
		drawStuff(ctx);
	});
</script>

<canvas bind:this={canvasElement}></canvas>
```



## 组件绑定

```html
bind:property={variable}

bind:this={component_instance}
```

可以使用相同的机制绑定到组件属性.

```html
<Keypad bind:value={pin}/>
```

组件同样支持 `bind:this`, 可以让你直接和组件实例交互。

> 注意，我们可以执行`{cart.empty}`而不是`{（）=>cart.empty（）}`，因为组件方法是闭包。当执行他们的时候，不需要担心。

```html
<ShoppingCart bind:this={cart}/>

<button on:click={cart.empty}>
	Empty shopping cart
</button>
```